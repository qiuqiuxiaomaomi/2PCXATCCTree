# 2PCXATCCTree
分布式事务技术研究


![](https://i.imgur.com/bvXOS8b.png)

应用场景：
      从支付宝转账1万块钱到余额宝的动作分为两步：
      1）支付宝表扣除1万：update A set amount=amount-10000 where userId=1;
      2）余额宝表增加1万：update B set amount=amount+10000 where userId=1;

<pre>
2PC：
      1）Client发起一个开始请求到协调器
      2）TC先将prepare消息写入本地日志，然后向所有的Server发起prepare消息。
         TC给A的消息是支付宝账户扣款1万，TC给B的消息是余额宝账户收款1万。
      3）A和B收到prepare消息后，执行具体本机事务，但不会进行commit，如果成功返回yes,
         失败返回no,同理，返回前都应把要返回的信息写到日志里
      5）TC收集所有执行器（A,B数据库）返回的消息。
             1）如果所有的执行器都返回yes，那么给所有执行器发送commit消息，执行器收
                到commit消息后执行本地事务的commit操作；
             2）如果有任一个执行器返回no，那么给所有的执行器发送abort消息，执行器收到
                abort消息后执行事务abort操作。
      
      TC或者执行器把发送和接收到的消息先写到日志里，只要是为了故障恢复。如果某个执行器从
      故障中恢复后，如果已经收到commit，则提交，如果收到abort则回滚，如果是yes，则再向
      TC询问一下，如果什么都没有，则很可能prepare阶段执行器就挂掉了，因此需要回滚。

      两阶段提交的性能是在太差。
          1）两阶段提交设计多次节点间的网络通信
          2）事务时间相对边长了，锁定的资源的时间也边长了，造成资源等待时间增加很长。

      正是由于2PC两阶段提交存在很严重的性能问题，所以，大部分的高并发服务都避免适用2PC。
</pre>