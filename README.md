# 2PCXATCCTree
分布式事务技术研究


![](https://i.imgur.com/bvXOS8b.png)

应用场景：
      从支付宝转账1万块钱到余额宝的动作分为两步：
      1）支付宝表扣除1万：update A set amount=amount-10000 where userId=1;
      2）余额宝表增加1万：update B set amount=amount+10000 where userId=1;

<pre>
2PC：
      1）Client发起一个开始请求到协调器
      2）TC先将prepare消息写入本地日志，然后向所有的Server发起prepare消息。
         TC给A的消息是支付宝账户扣款1万，TC给B的消息是余额宝账户收款1万。
      3）A和B收到prepare消息后，执行具体本机事务，但不会进行commit，如果成功返回yes,
         失败返回no,同理，返回前都应把要返回的信息写到日志里
      5）TC收集所有执行器（A,B数据库）返回的消息。
             1）如果所有的执行器都返回yes，那么给所有执行器发送commit消息，执行器收
                到commit消息后执行本地事务的commit操作；
             2）如果有任一个执行器返回no，那么给所有的执行器发送abort消息，执行器收到
                abort消息后执行事务abort操作。
      
      TC或者执行器把发送和接收到的消息先写到日志里，只要是为了故障恢复。如果某个执行器从
      故障中恢复后，如果已经收到commit，则提交，如果收到abort则回滚，如果是yes，则再向
      TC询问一下，如果什么都没有，则很可能prepare阶段执行器就挂掉了，因此需要回滚。

      两阶段提交的性能是在太差。
          1）两阶段提交设计多次节点间的网络通信
          2）事务时间相对边长了，锁定的资源的时间也边长了，造成资源等待时间增加很长。

      另外2PC还存在以下问题：
          1）单点：
             事务协调器存在单点问题，如果事务协调器出现故障，参与者将一直处于锁定状态
          2）脑裂
             在阶段2中，如果只有部分参与者接收并执行了Commit请求，会导致节点数据不一致。

      正是由于2PC两阶段提交存在很严重的性能问题，所以，大部分的高并发服务都避免适用2PC。
</pre>

![](https://i.imgur.com/CBvQzSy.png)

<pre>
3PC 三阶段提交协议

      无论2PC或3PC，均无法彻底解决分布式一致性问题
</pre>


![](https://i.imgur.com/Zbe3RRT.png)

<pre>
TCC 柔性事务
      Try-Confirm-Cancel模型
      将整个操作分为3个阶段：Try阶段 Catch阶段 Cancel阶段
      两个微服务同时进行Try,在Try阶段会进行数据的校验，检查，资源的预创建，如果都成功就会
   分别进行Confirm，如果两者都成功则完成整个TCC事务。如果Confirm时有一个服务有问题，则会
   转向Cancel，相当于Confirm的逆向操作。

   举个例子，假入 Bob 要向 Smith 转账，思路大概是：我们有一个本地方法，里面依次调用
      1、首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。
      2、在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。
      3、如果第2步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。

   优点：跟2PC比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也要差一些。
   缺点：需要程序员在实际的应用中根据业务场景定制补偿机制
</pre>